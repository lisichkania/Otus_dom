# Виды индексов. Работа с индексами и оптимизация запросов 
## 1. Создать индекс к какой-либо из таблиц вашей БД

*Cоздаём таблицу с тремя полями. Первое поле содержит числа от 1 до 100000, и по нему создан индекс. Второе поле содержит различные ASCII-символы, кроме непечатных. Третье поле содержит логическое значение, истинное примерно для 1% строк, и ложное для остальных. Строки вставлены в таблицу в случайном порядке.*
```
postgres=# create table t(a integer, b text, c boolean);
CREATE TABLE
postgres=# insert into t(a,b,c)
  select s.id, chr((32+random()*94)::integer), random() < 0.01
  from generate_series(1,500000) as s(id)
  order by random();
INSERT 0 500000
postgres=# create index on t(a);
CREATE INDEX
postgres=# analyze t;
ANALYZE
```
## 2. Прислать текстом результат команды explain, в которой используется данный индекс

*Попробуем выбрать значение по условию «a = 1».*
```
postgres=# explain (costs off) select * from t where a = 1;
          QUERY PLAN
-------------------------------
 Index Scan using t_a_idx on t
   Index Cond: (a = 1)
(2 rows)
```
*В данном случае оптимизатор принял решение использовать индексное сканирование (Index Scan). При индексном просмотре метод доступа возвращает значения TID по одному, до тех пор, пока подходящие строки не закончатся. Механизм индексирования по очереди обращается к тем страницам таблицы, на которые указывают TID, получает версию строки, проверяет ее видимость в соответствии с правилами многоверсионности, и возвращает полученные данные.*

*При выборке по диапазону значений он так же предлагает использовать индексное сканирование*
```
postgres=# explain (costs off) select * from t where a <= 100;
          QUERY PLAN
-------------------------------
 Index Scan using t_a_idx on t
   Index Cond: (a <= 100)
(2 rows)
```

*Если условия наложены на несколько полей таблицы, и эти поля проиндексированы, сканирование битовой карты позволяет (если оптимизатор сочтет это выгодным) использовать несколько индексов одновременно.*
```
postgres=# create index on t(b);
CREATE INDEX
postgres=# analyze t;
ANALYZE
postgres=# explain (costs off) select * from t where a <= 100 and b = 'a';
                    QUERY PLAN
--------------------------------------------------
 Bitmap Heap Scan on t
   Recheck Cond: ((a <= 100) AND (b = 'a'::text))
   ->  BitmapAnd
         ->  Bitmap Index Scan on t_a_idx
               Index Cond: (a <= 100)
         ->  Bitmap Index Scan on t_b_idx
               Index Cond: (b = 'a'::text)
(7 rows)
```

*Здесь узел BitmapAnd объединяет две битовые карты с помощью битовой операции «и». Сканирование по битовой карте позволяет избежать повторных обращений к одной и той же странице данных.*

*Для полноты картины следует сказать, что при неселективном условии оптимизатор предпочтет использованию индекса последовательное сканирование таблицы целиком.*

```

```

## 3. Реализовать индекс для полнотекстового поиска

**
```

```
## 4. Реализовать индекс на часть таблицы или индекс на поле с функцией

**
```

```
## 5. Создать индекс на несколько полей

**
```

```
## 6. Написать комментарии к каждому из индексов

**
```

```
## 7. Описать что и как делали и с какими проблемами столкнулись

**
